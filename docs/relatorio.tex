\documentclass[12pt]{article}
\usepackage[T1]{fontenc}
\usepackage{dot2texi}

\usepackage{tikz}
\usepackage{listings}

\usepackage{pgfplots}
\pgfplotsset{width=10cm,compat=1.9}

\usepackage{color}

\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\definecolor{mymauve}{rgb}{0.58,0,0.82}

\lstset{ %
  backgroundcolor=\color{white},   % choose the background color; you must add \usepackage{color} or \usepackage{xcolor}
  basicstyle=\footnotesize,        % the size of the fonts that are used for the code
  breakatwhitespace=false,         % sets if automatic breaks should only happen at whitespace
  breaklines=true,                 % sets automatic line breaking
  captionpos=b,                    % sets the caption-position to bottom
  commentstyle=\color{mygreen},    % comment style
  deletekeywords={...},            % if you want to delete keywords from the given language
  escapeinside={\%*}{*)},          % if you want to add LaTeX within your code
  extendedchars=true,              % lets you use non-ASCII characters; for 8-bits encodings only, does not work with UTF-8
  frame=L,    	                   % adds a frame around the code
  keepspaces=true,                 % keeps spaces in text, useful for keeping indentation of code (possibly needs columns=flexible)
  keywordstyle=\color{blue},       % keyword style
  otherkeywords={*,...},           % if you want to add more keywords to the set
  numbers=left,                    % where to put the line-numbers; possible values are (none, left, right)
  numbersep=5pt,                   % how far the line-numbers are from the code
  numberstyle=\tiny\color{mygray}, % the style that is used for the line-numbers
  rulecolor=\color{black},         % if not set, the frame-color may be changed on line-breaks within not-black text (e.g. comments (green here))
  showspaces=false,                % show spaces everywhere adding particular underscores; it overrides 'showstringspaces'
  showstringspaces=false,          % underline spaces within strings only
  showtabs=false,                  % show tabs within strings adding particular underscores
  stepnumber=2,                    % the step between two line-numbers. If it's 1, each line will be numbered
  stringstyle=\color{mymauve},     % string literal style
  tabsize=2,	                   % sets default tabsize to 2 spaces
  title=\lstname                   % show the filename of files included with \lstinputlisting; also try caption instead of title
}

\usepackage{float}
\usepackage{graphicx}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{wrapfig}
\usetikzlibrary{shapes,arrows}
\usepackage{bchart}

\makeatletter
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Textclass specific LaTeX commands.
\newenvironment{lyxlist}[1]
{\begin{list}{}
{\settowidth{\labelwidth}{#1}
 \setlength{\leftmargin}{\labelwidth}
 \addtolength{\leftmargin}{\labelsep}
 \renewcommand{\makelabel}[1]{##1\hfil}}}
{\end{list}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% User specified LaTeX commands.
%\usepackage{sbc-template}

\usepackage[brazil]{babel}
\usepackage[utf8]{inputenc}

\usepackage[portuguese,ruled,vlined]{algorithm2e}
\usepackage{algorithmic}

\SetKwInput{Classe}{Classe}


\sloppy

\pagenumbering{arabic}

\title{Minimização de Valores de Arestas em um Grafo}

\author{Pedro Vanzella}

\makeatother

\usepackage{babel}
\usepackage{listings}
\lstset {
    mathescape,
    frame=none
}
\renewcommand{\lstlistingname}{Listagem}

\begin{document}

\maketitle

\section{Introdução}\label{sec:intro}

Uma recente mudança na regulamentação de impostos reativou uma antiga taxa sobre
operações financeiras. Esta taxa, chamada de CPMF, incide em $\%$ sobre toda e qualquer
transação bancária.

Um banco teve a idéia de minimizar o valor total pago deste imposto através de
atalhos em transferências realizadas internamente.

Por exemplo, digamos que haja cinco correntistas, $1$, $2$, $3$, $4$
 e $5$, e haja as seguintes transferências entre eles:
\begin{list}{}{}
  \item $1$ transfere $\$500$ para $2$.
  \item $2$ transfere $\$230$ para $3$.
  \item $3$ transfere $\$120$ para $4$.
  \item $1$ transfere $\$120$ para $4$.
  \item $2$ transfere $\$200$ para $5$.
\end{list}

% TODO: Colocar estas duas listas em subfigures e referenciá-las

É possível fazer quatro transferências, respeitando os valores iniciais e finais
de saldo das contas destes cinco correntistas, mas minimizando o valor de cada
transferência, de modo a pagar menos imposto:

\begin{list}{}{}
  \item $1$ transfere $\$70$ para $2$
  \item $1$ transfere $\$110$ para $3$
  \item $1$ transfere $\$240$ para $4$
  \item $1$ transfere $\$200$ para $5$
\end{list}

Podemos ver que, em ambos os casos, o total enviado e o total recebido não foi
alterado~-~apenas os valores parciais mudaram e, com eles, o valor pago em impostos.

Do ponto de vista dos correntistas, nada mudou~-~\textit{e.g.} o extrato do
correntista $1$ ainda mostrará duas transferências, uma de $\$500$ para o
correntista $2$ e uma de $\$120$ para o correntista $4$~-~, mas internamente as
transferências realizadas foram bastante diferentes.

\begin{figure}[htb!]
  \centering
  \begin{subfigure}[b]{0.5\textwidth}
    \begin{dot2tex}[neato,options=-tmath]
        \input{test_trivial.txt.input.dot}
    \end{dot2tex}
    \caption{Entrada}
    \label{fig:intro:entrada}
  \end{subfigure}%
  ~
  \begin{subfigure}[b]{0.5\textwidth}
    \begin{dot2tex}[neato,options=-tmath]
        \input{test_trivial.txt.reduced.dot}
    \end{dot2tex}
    \caption{Saída}
    \label{fig:intro:saída}
  \end{subfigure}
  \caption{Representação da entrada e da saída como grafos}
  \label{fig:intro}
\end{figure}

\section{Entrada}\label{sec:entrada}

\begin{wrapfigure}{r}{0.3\textwidth}
  \vspace{-20pt}
  \begin{center}
    \begin{lstlisting}
    5 5
    1 2 500
    2 3 230
    3 4 120
    1 4 120
    2 5 200
    \end{lstlisting}
  \end{center}
  \caption{Arquivo de entrada}
  \vspace{-10pt}
\label{fig:entrada:file}
\end{wrapfigure}

O arquivo de entrada é algo no formato mostrado na Figura~\ref{fig:entrada:file}.
A primeira linha tem dois valores: a quantidade de correntistas e a quantidade
de transações descritas no arquivo. Como veremos na Sessão~\ref{sec:estrutura},
estas informações não serão necessárias.

As linhas seguintes têm três valores cada: o correntista que originou a
transação, o correntista de destino da transação, e o valor da transação. Por
exemplo, na linha 2 da Figura~\ref{fig:entrada:file}, lemos ``\textit{Uma
  transferência de 500 da conta do correntista 1 para a conta do correntista 2.}''.

\section{Estrutura de Dados}\label{sec:estrutura}

Inicialmente, pensou-se em utilizar \textit{hashes} um de nodos e um de arestas.
O problema com isto é que, ao iterar por um \textit{hash}, não se pode alterar
seu tamanho.

Resolveu-se então utilizar-se listas de adjacência, com a estrutura mostrada na
Figura~\ref{fig:estrutura:classes}.

\begin{figure}[htb!]
    \begin{lstlisting}
class Graph:
    public list<Node> nodes

    class Node:
        public int val
        public list<Edge> edges

    class Edge:
        public Node from
        public Node to
        public int val
    \end{lstlisting}
  \caption{Representação das classes do grafo}
\label{fig:estrutura:classes}
\end{figure}

Para ler o arquivo de entrada e criar os nodos e arestas, utilizamos o
Algoritmo~\ref{alg:estrtutura:leitura}. Veja que ele está na classe
\textsf{\textbf{Mardita}}, que contém uma instância do grafo.

\begin{algorithm}[H]
 \caption{Criação de Nodos e Arestas}
 \label{alg:estrutura:leitura}
 \Classe{Mardita}
 \Entrada{Arquivo como o da Figura~\ref{fig:entrada:file}}
 \Saida{Instância da classe \textsf{\textbf{Graph}}}
 \ParaCada{linha l no arquivo, exceto a primeira}
    {
        partes $\gets$ l.separa(' ') \tcc*[r]{Separa a linha nos espaços}

        nodo\_a $\gets$ self.graph.add\_node(partes[0])

        nodo\_b $\gets$ self.graph.add\_node(partes[1])

        nodo\_a.add\_edge(nodo\_b, partes[2]) \tcc*[r]{Liga A com B, com valor partes[2]}
    }
\end{algorithm}

Onde \textsf{add\_node} está descrito na Figura~\ref{fig:estrutura:alg:add_node}
e \textsf{add\_edge} está descrito na Figura~\ref{fig:estrutura:alg:add_edge}.

\begin{algorithm}[H]
  \caption{Criação de Nodos}
  \label{alg:estrutura:add_node}
  \Classe{Graph}
  \Entrada{val: Inteiro, representando o nome do Nodo}
  \Saida{Instância da classe \textbf{\textsf{Node}}}
  \ParaTodo{n em self.nodes}
  {
    \Se{n.val $=$ val}
    {
      \Retorna{n} \tcc*[r]{Se o nodo já existe, retorna ele}
    }
    n $\gets$ Graph.Node(val) \tcc*[r]{Chama o construtor de Node}
    self.nodes.add(n) \tcc*[r]{Adiciona à lista de nodos}
    \Retorna{n}
  }
\end{algorithm}

O Algoritmo~\ref{alg:estrutura:add_node},
que pertence à classe \textsf{\textbf{Graph}}, primeiro verifica se já há um
nodo com este nome em sua coleção de nodos. Caso haja, retorna ele. Se não
houver, chama o construtor da classe \textsf{\textbf{Node}} para criar um novo
nodo, adiciona à sua coleção e então retorna o nodo criado.

A primeira vista, poderíamos ter utilizado um \textit{set} em vez de uma lista
para armazenar a coleção de nodos, dado que não queremos dois nodos iguais nela.
No entanto, a unicidade garantida seria do objeto nodo, quando queremos na
verdade a unicidade do nome do nodo.

Caso a implementação tivesse sido feita com um hash, o algoritmo seria como o
descrito no Algoritmo~\ref{alg:estrutura:add_node_hash}.

\begin{algorithm}[H]
  \caption{Criação de Nodo, caso a classe seja implementada com um Hash}
  \label{alg:estrutura:add_node_hash}
  \Classe{Graph}
  \Entrada{val: Inteiro, representando o nome do Nodo}
  self.nodes[val] $=$ True
\end{algorithm}

Veja que esta versão de \textsf{add\_node} não precisa verificar a existência do
nodo. No entanto, também não há uma classe \textsf{\textbf{Node}}, e não
retornamos nada. O modo de acesso seria ligeiramente diferente.

\begin{algorithm}[H]
  \caption{Criação de Arestas}
  \label{alg:estrutura:add_edge}
  \Classe{Node}
  \Entrada{to: Nodo de origem; val: Inteiro, representando o valor da aresta}
  \Saida{Instancia da classe \textsf{\textbf{Edge}}}
  \ParaCada{e em self.edges}
  {
    \Se{e.to $=$ to}
    {
      \Retorna{e.update(val)} \tcc*[r]{Se a aresta já existe, aumenta seu valor}
    }
    e $\gets$ Graph.Edge(self, to, val) \tcc*[r]{Cria nova Edge}
    self.edges.add(e) \tcc*[r]{Adiciona à coleção de arestas}
    \Retorna{e}
  }
\end{algorithm}

O Algoritmo~\ref{alg:estrutura:add_edge} é
parecido com o Algoritmo~\ref{alg:estrutura:add_node}, pois ele verifica a unicidade da
aresta. A diferença é que arestas são consideradas iguais caso suas origens e
destinos sejam iguais, para este problema. Como estamos verificando todas as
arestas que partem de um nodo, basta comparar o destino.

O construtor da aresta recebe três parâmetros: \textit{de onde}, \textit{para
  onde} e o \textit{valor} da aresta.

\section{Algoritmo}\label{sec:algoritmo}

Há duas coisas a serem feitas para resolver o problema: precisamos calcular
quanto imposto é pago (Sessão~\ref{sec:algoritmo:total_tax}) e reduzir o número
de arestas do grafo (Sessão~\ref{sec:algoritmo:reduce}).

\subsection{Cálculo de Total de Imposto Pago}\label{sec:algoritmo:total_tax}

Este algoritmo é executado duas vezes~-~uma antes de reduzir-se as arestas, e
uma após, de modo a sabermos qual foi a economia.

\begin{algorithm}[H]
  \caption{Cálculo de Imposto Pago}
  \label{alg:total_tax}
  \Classe{Mardita}
  \Entrada{Todas as arestas do grafo}
  \Saida{Total de imposto pago}
  total $\gets$ $0$

  \ParaTodo{e em self.graph.edges}
  {
    total $\gets$ total $+$ e.valor
  }
  \Retorna{total $\times$ $0.01$}
\end{algorithm}

No Algoritmo~\ref{alg:total_tax} vemos como o total de imposto é
calculado. Apenas soma-se o valor de todas as arestas e multiplica-se por
$0.01$, que é o valor do imposto.

Nota-se que está acessando-se a propriedade \textsf{edges} da classe
\textsf{\textbf{Graph}}, mas a mesma não parecia ter acesso às arestas, conforme
visto na Figura~\ref{fig:estrutura:classes}.

De fato, a lista de arestas está na classe \textsf{\textbf{Node}}. Para termos
acesso a elas, basta termos um método na classe \textsf{\textbf{Graph}} que
itera por todos os nodos, coletando todas as arestas. A unicidade das arestas é
garantida no momento de inserção, então pode-se fazer como é visto no Algoritmo~\ref{alg:all_edges}.

\begin{algorithm}[H]
  \caption{Coleção de todas as arestas}
  \label{alg:all_edges}
  \Classe{Node}
  \Entrada{Uma instância da classe \textsf{textbf{Graph}}}
  \Saida{Uma lista de instâncias da classe \textsf{\textbf{Edge}}}
  inicializa edges como uma lista vazia

  \ParaTodo{n em self.nodes}
  {
    \ParaTodo{e em n.edges}
    {
      adiciona e em edges
    }
  }

  \Retorna{edges}
\end{algorithm}

\subsection{Redução das Arestas}\label{sec:algoritmo:reduce}

Este é o algoritmo principal, onde o problema é de fato solucionado. O
pseudocódigo pode ser visto na Figura~\ref{fig:algoritmo:reduce_edges}.

\begin{figure}[htb!]
  \centering
\begin{lstlisting}
void Mardita::reduce_edges():
    Para todo nodo u em self.graph.nodes:
        Para cada nodo v adjacente a u:
            Para cada nodo a adjacente a v:
                 se valor(Aresta<v, a>) < valor(Aresta<u, v>):
                     tmp = valor(Aresta<v, a>)
                     remove Aresta<v, a>
                     valor(Aresta<u, v>) diminui de tmp

                     se ja existe aresta entre u e a:
                          valor(Aresta<u, a>) aumenta de tmp
                     senao:
                          cria Aresta<u, a> com valor tmp
\end{lstlisting}
  \caption{Algoritmo que reduz as arestas}
\label{fig:algoritmo:reduce_edges}
\end{figure}

A idéia do algoritmo de Redução de Arestas é encontrar transitividade entre os
nodos~-~isto é, para um grafo $G = {n, e}$ com $n = {A, B, C}$ e $e = {(A, B, x),
  (B, C, y)}$, gerar uma nova aresta $(A, C, x - y)$, remover a aresta $(B, C,
x)$ e alterar o valor da aresta $(A, B)$ para $y - x$.

Para isto, encontra-se os ``amigos dos amigos'' de cada nodo no grafo (linhas
2-4 da Figura~\ref{fig:algoritmo:reduce_edges}). A verificação da linha 5 é
importante para que não criemos uma transação de valor negativo.

Caso a verificação da linha 5 seja positiva, podemos atualizar o valor da
primeira aresta $(u, v)$, subtraindo o valor da aresta $(v, a)$. Também
removemos a aresta $(v, a)$ do grafo.

O próximo passo é criar a aresta $(u, a)$. Há um porém: a aresta $(u, a)$ pode
já existir. Neste caso, apenas soma-se o valor da aresta $(v, a)$. Caso a aresta
não exista, cria-se uma aresta $(u, a)$ com o valor da aresta $(v, a)$.

Um exemplo mínimo disto pode ser visto na Figura~\ref{fig:reduce:abc}.

\begin{figure}[H]
  \centering
  \begin{subfigure}[b]{0.5\textwidth}
    \begin{dot2tex}[neato,options=-tmath]
        \input{test_abc.input.dot}
    \end{dot2tex}
    \caption{Entrada}
    \label{fig:reduce:abc:entrada}
  \end{subfigure}%
  ~
  \begin{subfigure}[b]{0.5\textwidth}
    \begin{dot2tex}[neato,options=-tmath]
        \input{test_abc.reduced.dot}
    \end{dot2tex}
    \caption{Saída}
    \label{fig:reduce:abc:saida}
  \end{subfigure}
  \caption{Redução aplicada a um grafo simples.}
  \label{fig:reduce:abc}
\end{figure}

Pode-se facilmente validar o algoritmo com um teste de mesa na
Figura~\ref{fig:reduce:abc}, ou mesmo na Figura~\ref{fig:intro}.

Olhando-se para a Figura~\ref{fig:reduce:abc}, vemos que os saldos dos
correntistas são os mesmos (\textit{i.e.}, o correntista $1$ teve uma redução de
$100$ em seu saldo, o correntista $2$ teve um aumento de $50$, bem como o
correntista $3$). A única coisa que mudou entre a
Figura~\ref{fig:reduce:abc:entrada} e a Figura~\ref{fig:reduce:abc:saida} foram
os valores e os destinos das transferências. Somando-se e multiplicando pelo
valor do imposto, vemos que na Figura~\ref{fig:reduce:abc:entrada} pagaríamos
$1.50$ de imposto (\textit{i.e.}, $1\%$ de $150$), enquanto na
Figura~\ref{fig:reduce:abc:saida} pagaríamos $1.00$ de impost (\textit{i.e.},
$1\%$ de $100$).


\subsection{Detalhes de Implementação}

Note que há um detalhe de implementação no algoritmo da
Figura~\ref{fig:algoritmo:reduce_edges}: dependendo da linguagem, ao ler os
adjacentes de um nodo, teremos uma cópia da lista de adjacentes. Ao inserir uma
nova aresta em um nodo, esta lista possivelmente não seria alterada, e é
importante analisarmos esta nova aresta também.

Neste caso, deve ser utilizada a versão da Figura~\ref{fig:algoritmo:reduce_edges:push_pop}.

\begin{figure}[htb!]
  \centering
\begin{lstlisting}
void Mardita::reduce_edges():
    Para todo nodo u em self.graph.nodes:
        vs = adjacentes(u)
        Enquanto vs nao esta vazia
            v = vs.pop()
            Para cada nodo a adjacente a v:
                 se valor(Aresta<v, a>) < valor(Aresta<u, v>):
                     tmp = valor(Aresta<v, a>)
                     remove Aresta<v, a>
                     valor(Aresta<u, v>) diminui de tmp

                     se ja existe aresta entre u e a:
                          valor(Aresta<u, a>) aumenta de tmp
                     senao:
                          cria Aresta<u, a> com valor tmp
                          vs.add(a)
\end{lstlisting}
  \caption{Algoritmo que reduz as arestas, versão com uma lista auxiliar}
\label{fig:algoritmo:reduce_edges:push_pop}
\end{figure}

Vemos na Figura~\ref{fig:algoritmo:reduce_edges:push_pop} algumas diferenças que
auxiliam na implementação do algoritmo. Mais especificamente, em vez de
simplesmente iterarmos por todos os adjacentes de \textsf{u}, adicionamos todos
eles a uma lista (linha 3), e vamos removendo-os um a um, até que a lista
esvazie (linha 4). Sempre que uma aresta nova é criada, adicionamos esta aresta
à lista \textsf{vs} (linha 16).

Esta versão do algoritmo também resolveria o problema apresentado na
Sessão~\ref{sec:estrutura} com \textit{hashes}.

\section{Resultados}\label{sec:resultados}

\begin{table}[H]
  \centering
\begin{tabular}{||c|c||c|c|c||}
  \hline
Teste & Economia & Transações & Tempo de Execução \\ [0.5ex]
  \hline\hline
  1 & 3980.31 & 264 & 0.17s \\
  \hline
  2 & 3329.03 & 235 & 0.17s \\
  \hline
  3 & 1905.99 & 165 & 0.08s \\
  \hline
  4 & 1545.48 & 140 & 0.06s \\
  \hline
  5 & 925.53  & 99 & 0.06s \\
  \hline
  6 & 2288.34 & 186 & 0.10s \\
  \hline
  7 & 609.39  & 91 & 0.05s \\
  \hline
  8 & 3029.33 & 232 & 0.14s \\
  \hline
  9 & 1991.52 & 165 & 0.09s \\
  \hline
  10 & 1912.52 & 153 & 0.07s \\
\hline
\end{tabular}

\caption{Resultados dos testes da Turma 128}
\end{table}

É possível ver na Tabela~1 que há uma economia significativa
em cada um dos casos de teste, e o processamento ocorre em um tempo bem aceitável.

Vemos também que o tempo de processamento é proporcional ao número de
transações. Isto faz sentido, dado que cada transação é uma aresta no grafo.

De fato, o algoritmo passará por cada aresta uma vez, e apenas uma vez. Isto
daria uma complexidade de $O(e)$, onde $e$ é o número de arestas. No entanto,
novas arestas são criadas, e estas devem ser verificadas por transitividade, de
modo a otimizar ao máximo as transações. Como cada par de arestas pode gerar uma
nova aresta, a complexidade fica $O(e + \frac{e}{2})$. No entanto, a notação $O$
despresa os termos constantes, e ficamos novamente com $O(e)$.

\section{Conclusão}\label{sec:conclusao}

Há, possivelmente, a possibilidade de reduzir mais ainda algumas arestas. Esta é
apenas uma solução possível, e não necessariamente a melhor.

\end{document}
