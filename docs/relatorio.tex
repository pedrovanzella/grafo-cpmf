\documentclass[12pt]{article}
\usepackage[T1]{fontenc}
\usepackage{algorithm2e}
\usepackage{dot2texi}

\usepackage{tikz}
\usepackage{listings}

\usepackage{pgfplots}
\pgfplotsset{width=10cm,compat=1.9}

\usepackage{color}

\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\definecolor{mymauve}{rgb}{0.58,0,0.82}

\lstset{ %
  backgroundcolor=\color{white},   % choose the background color; you must add \usepackage{color} or \usepackage{xcolor}
  basicstyle=\footnotesize,        % the size of the fonts that are used for the code
  breakatwhitespace=false,         % sets if automatic breaks should only happen at whitespace
  breaklines=true,                 % sets automatic line breaking
  captionpos=b,                    % sets the caption-position to bottom
  commentstyle=\color{mygreen},    % comment style
  deletekeywords={...},            % if you want to delete keywords from the given language
  escapeinside={\%*}{*)},          % if you want to add LaTeX within your code
  extendedchars=true,              % lets you use non-ASCII characters; for 8-bits encodings only, does not work with UTF-8
  frame=L,    	                   % adds a frame around the code
  keepspaces=true,                 % keeps spaces in text, useful for keeping indentation of code (possibly needs columns=flexible)
  keywordstyle=\color{blue},       % keyword style
  otherkeywords={*,...},           % if you want to add more keywords to the set
  numbers=left,                    % where to put the line-numbers; possible values are (none, left, right)
  numbersep=5pt,                   % how far the line-numbers are from the code
  numberstyle=\tiny\color{mygray}, % the style that is used for the line-numbers
  rulecolor=\color{black},         % if not set, the frame-color may be changed on line-breaks within not-black text (e.g. comments (green here))
  showspaces=false,                % show spaces everywhere adding particular underscores; it overrides 'showstringspaces'
  showstringspaces=false,          % underline spaces within strings only
  showtabs=false,                  % show tabs within strings adding particular underscores
  stepnumber=2,                    % the step between two line-numbers. If it's 1, each line will be numbered
  stringstyle=\color{mymauve},     % string literal style
  tabsize=2,	                   % sets default tabsize to 2 spaces
  title=\lstname                   % show the filename of files included with \lstinputlisting; also try caption instead of title
}

\usepackage{float}
\usepackage{graphicx}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{wrapfig}
\usetikzlibrary{shapes,arrows}
\usepackage{bchart}

\makeatletter
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Textclass specific LaTeX commands.
\newenvironment{lyxlist}[1]
{\begin{list}{}
{\settowidth{\labelwidth}{#1}
 \setlength{\leftmargin}{\labelwidth}
 \addtolength{\leftmargin}{\labelsep}
 \renewcommand{\makelabel}[1]{##1\hfil}}}
{\end{list}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% User specified LaTeX commands.
%\usepackage{sbc-template}

\usepackage[brazil]{babel}
\usepackage[utf8]{inputenc}

\sloppy

\pagenumbering{arabic}

\title{Minimização de Valores de Arestas em um Grafo}

\author{Pedro Vanzella}

\makeatother

\usepackage{babel}
\usepackage{listings}
\lstset {
    mathescape,
    frame=none
}
\renewcommand{\lstlistingname}{Listagem}

\begin{document}

\maketitle

\section{Introdução}\label{sec:intro}

Uma recente mudança na regulamentação de impostos reativou uma antiga taxa sobre
operações financeiras. Esta taxa, chamada de CPMF, incide em $\%$ sobre toda e qualquer
transação bancária.

Um banco teve a idéia de minimizar o valor total pago deste imposto através de
atalhos em transferências realizadas internamente.

Por exemplo, digamos que haja cinco correntistas, $1$, $2$, $3$, $4$
 e $5$, e haja as seguintes transferências entre eles:
\begin{list}{}{}
  \item $1$ transfere $\$500$ para $2$.
  \item $2$ transfere $\$230$ para $3$.
  \item $3$ transfere $\$120$ para $4$.
  \item $1$ transfere $\$120$ para $4$.
  \item $2$ transfere $\$200$ para $5$.
\end{list}

% TODO: Colocar estas duas listas em subfigures e referenciá-las

É possível fazer quatro transferências, respeitando os valores iniciais e finais
de saldo das contas destes cinco correntistas, mas minimizando o valor de cada
transferência, de modo a pagar menos imposto:

\begin{list}{}{}
  \item $1$ transfere $\$70$ para $2$
  \item $1$ transfere $\$110$ para $3$
  \item $1$ transfere $\$240$ para $4$
  \item $1$ transfere $\$200$ para $5$
\end{list}

Podemos ver que, em ambos os casos, o total enviado e o total recebido não foi
alterado~-~apenas os valores parciais mudaram e, com eles, o valor pago em impostos.

Do ponto de vista dos correntistas, nada mudou~-~\textit{e.g.} o extrato do
correntista $1$ ainda mostrará duas transferências, uma de $\$500$ para o
correntista $2$ e uma de $\$120$ para o correntista $4$~-~, mas internamente as
transferências realizadas foram bastante diferentes.

\begin{figure}[htb!]
  \centering
  \begin{subfigure}[b]{0.5\textwidth}
    \begin{dot2tex}[neato,options=-tmath]
        \input{test_trivial.txt.input.dot}
    \end{dot2tex}
    \caption{Entrada}
    \label{fig:intro:entrada}
  \end{subfigure}%
  ~
  \begin{subfigure}[b]{0.5\textwidth}
    \begin{dot2tex}[neato,options=-tmath]
        \input{test_trivial.txt.reduced.dot}
    \end{dot2tex}
    \caption{Saída}
    \label{fig:intro:saída}
  \end{subfigure}
  \caption{Representação da entrada e da saída como grafos}
  \label{fig:intro}
\end{figure}

\section{Entrada}\label{sec:entrada}

\begin{wrapfigure}{r}{0.3\textwidth}
  \vspace{-20pt}
  \begin{center}
    \begin{lstlisting}
    5 5
    1 2 500
    2 3 230
    3 4 120
    1 4 120
    2 5 200
    \end{lstlisting}
  \end{center}
  \caption{Arquivo de entrada}
  \vspace{-10pt}
\label{fig:entrada:file}
\end{wrapfigure}

O arquivo de entrada é algo no formato mostrado na Figura~\ref{fig:entrada:file}.
A primeira linha tem dois valores: a quantidade de correntistas e a quantidade
de transações descritas no arquivo. Como veremos na Sessão~\ref{sec:estrutura},
estas informações não serão necessárias.

As linhas seguintes têm três valores cada: o correntista que originou a
transação, o correntista de destino da transação, e o valor da transação. Por
exemplo, na linha 2 da Figura~\ref{fig:entrada:file}, lemos ``\textit{Uma
  transferência de 500 da conta do correntista 1 para a conta do correntista 2.}''.

\section{Estrutura de Dados}\label{sec:estrutura}

Inicialmente, pensou-se em utilizar \textit{hashes} um de nodos e um de arestas.
O problema com isto é que, ao iterar por um \textit{hash}, não se pode alterar
seu tamanho.

Resolveu-se então utilizar-se listas de adjacência, com a estrutura mostrada na
Figura~\ref{fig:estrutura:classes}.

\begin{figure}[htb!]
    \begin{lstlisting}
class Graph:
    public list<Node> nodes

    class Node:
        public int val
        public list<Edge> edges

    class Edge:
        public Node from
        public Node to
        public int val
    \end{lstlisting}
  \caption{Representação das classes do grafo}
\label{fig:estrutura:classes}
\end{figure}

Para ler o arquivo de entrada e criar os nodos e arestas, utilizamos o algoritmo
da Figura~\ref{fig:estrutura:alg:leitura}. Veja que ele está na classe
\textsf{\textbf{Mardita}}, que contém uma instância do grafo.

\begin{figure}[htb!]
  \centering
\begin{lstlisting}
void Mardita::read_file(arquivo)
    Para cada linha l no arquivo, exceto a primeira:
        partes = l.separa(' ')

        nodo_a = self.graph.add_node(partes[0])
        nodo_b = self.graph.add_node(partes[1])

        nodo_a.add_edge(nodo_b, partes[2])
\end{lstlisting}
  \caption{Algoritmo de criação de nodos e arestas}
\label{fig:estrutura:alg:leitura}
\end{figure}

Onde \textsf{add\_node} está descrito na Figura~\ref{fig:estrutura:alg:add_node}
e \textsf{add\_edge} está descrito na Figura~\ref{fig:estrutura:alg:add_edge}.

\begin{figure}[htb!]
  \centering
\begin{lstlisting}
Node Graph::add_node(val):
    para todo n em self.nodes:
        se n.val == val:
            return n
    n = Graph.Node(val)
    self.nodes.add(n)
    return n
\end{lstlisting}
  \caption{Algoritmo de criação de nodos e arestas}
\label{fig:estrutura:alg:add_node}
\end{figure}

O algoritmo \textsf{add\_node} (Figura~\ref{fig:estrutura:alg:add_node}),
que pertence à classe \textsf{\textbf{Graph}}, primeiro verifica se já há um
nodo com este nome em sua coleção de nodos. Caso haja, retorna ele. Se não
houver, chama o construtor da classe \textsf{\textbf{Node}} para criar um novo
nodo, adiciona à sua coleção e então retorna o nodo criado.

A primeira vista, poderíamos ter utilizado um \textit{set} em vez de uma lista
para armazenar a coleção de nodos, dado que não queremos dois nodos iguais nela.
No entanto, a unicidade garantida seria do objeto nodo, quando queremos na
verdade a unicidade do nome do nodo.

Caso a implementação tivesse sido feita com um hash, o algoritmo seria como o
descrito na Figura~\ref{fig:estrutura:alg:add_node_hash}.

\begin{figure}[htb!]
  \centering
\begin{lstlisting}
void Graph::add_node(val):
    self.nodes[val] = True
\end{lstlisting}
  \caption{Algoritmo de criação de nodos e arestas}
\label{fig:estrutura:alg:add_node_hash}
\end{figure}

Veja que esta versão de \textsf{add\_node} não precisa verificar a existência do
nodo. No entanto, também não há uma classe \textsf{\textbf{Node}}, e não
retornamos nada. O modo de acesso seria ligeiramente diferente.

\begin{figure}[htb!]
  \centering
\begin{lstlisting}
Edge Node::add_edge(to, val):
    para cada e em self.edges:
        se e.to == to:
            return e

    e = Graph.Edge(self, to, val)
    self.edges.add(e)
    return e
\end{lstlisting}
  \caption{Algoritmo de criação de nodos e arestas}
\label{fig:estrutura:alg:add_edge}
\end{figure}

O algoritmo \textsf{add\_edge} (Figura~\ref{fig:estrutura:alg:add_edge}) é
parecido com o algoritmo \textsf{add\_node}
(Figura~\ref{fig:estrutura:alg:add_node}), pois ele verifica a unicidade da
aresta. A diferença é que arestas são consideradas iguais caso suas origens e
destinos sejam iguais, para este problema. Como estamos verificando todas as
arestas que partem de um nodo, basta comparar o destino.

O construtor da aresta recebe três parâmetros: \textit{de onde}, \textit{para
  onde} e o \textit{valor} da aresta.

\section{Algoritmo}\label{sec:algoritmo}

Há duas coisas a serem feitas para resolver o problema: precisamos calcular
quanto imposto é pago (Sessão~\ref{sec:algoritmo:total_tax}) e reduzir o número
de arestas do grafo (Sessão~\ref{sec:algoritmo:reduce}).

\subsection{Cálculo de Total de Imposto Pago}\label{sec:algoritmo:total_tax}

Este algoritmo é executado duas vezes~-~uma antes de reduzir-se as arestas, e
uma após, de modo a sabermos qual foi a economia.

\begin{figure}[htb!]
  \centering
\begin{lstlisting}
float Mardita::total_tax_payed():
    total = 0
    Para todo e em self.graph.edges:
         total += e.valor
    return total * 0.01
\end{lstlisting}
  \caption{Algoritmo de cálculo do total de imposto pago}
\label{fig:algoritmo:total_tax}
\end{figure}

Na Figura~\ref{fig:algoritmo:total_tax} vemos como o total de imposto é
calculado. Apenas soma-se o valor de todas as arestas e multiplica-se por
$0.01$, que é o valor do imposto.

Nota-se que está acessando-se a propriedade \textsf{edges} da classe
\textsf{\textbf{Graph}}, mas a mesma não parecia ter acesso às arestas, conforme
visto na Figura~\ref{fig:estrutura:classes}.

De fato, a lista de arestas está na classe \textsf{\textbf{Node}}. Para termos
acesso a elas, basta termos um método na classe \textsf{\textbf{Graph}} que
itera por todos os nodos, coletando todas as arestas. A unicidade das arestas é
garantida no momento de inserção, então pode-se fazer como é visto na Figura~\ref{fig:algoritmo:all_edges}.

\begin{figure}[htb!]
  \centering
\begin{lstlisting}
List<Edge> Graph::edges():
    edges = [] // Lista vazia
    Para todo n em self.nodes:
        para todo e em n.edges:
            edges.add(e)
    return edges
\end{lstlisting}
  \caption{Algoritmo que coleta todas as arestas de todos os nodos}
\label{fig:algoritmo:all_edges}
\end{figure}

\subsection{Redução das Arestas}\label{sec:algoritmo:reduce}

Este é o algoritmo principal, onde o problema é de fato solucionado. O
pseudocódigo pode ser visto na Figura~\ref{fig:algoritmo:reduce_edges}.

\begin{figure}[htb!]
  \centering
\begin{lstlisting}
void Mardita::reduce_edges():
    Para todo nodo u em self.graph.nodes:
        Para cada nodo v adjacente a u:
            Para cada nodo a adjacente a v:
                 se valor(Aresta<v, a>) < valor(Aresta<u, v>):
                     tmp = valor(Aresta<v, a>)
                     remove Aresta<v, a>
                     valor(Aresta<u, v>) diminui de tmp

                     se ja existe aresta entre u e a:
                          valor(Aresta<u, a>) aumenta de tmp
                     senao:
                          cria Aresta<u, a> com valor tmp
\end{lstlisting}
  \caption{Algoritmo que reduz as arestas}
\label{fig:algoritmo:reduce_edges}
\end{figure}

A idéia do algoritmo de Redução de Arestas é encontrar transitividade entre os
nodos~-~isto é, para um grafo $G = {n, e}$ com $n = {A, B, C}$ e $e = {(A, B, x),
  (B, C, y)}$, gerar uma nova aresta $(A, C, x - y)$, remover a aresta $(B, C,
x)$ e alterar o valor da aresta $(A, B)$ para $y - x$.

Para isto, encontra-se os ``amigos dos amigos'' de cada nodo no grafo (linhas
2-4 da Figura~\ref{fig:algoritmo:reduce_edges}). A verificação da linha 5 é
importante para que não criemos uma transação de valor negativo.

Caso a verificação da linha 5 seja positiva, podemos atualizar o valor da
primeira aresta $(u, v)$, subtraindo o valor da aresta $(v, a)$. Também
removemos a aresta $(v, a)$ do grafo.

O próximo passo é criar a aresta $(u, a)$. Há um porém: a aresta $(u, a)$ pode
já existir. Neste caso, apenas soma-se o valor da aresta $(v, a)$. Caso a aresta
não exista, cria-se uma aresta $(u, a)$ com o valor da aresta $(v, a)$.

Um exemplo mínimo disto pode ser visto na Figura~\ref{fig:reduce:abc}.

\begin{figure}[H]
  \centering
  \begin{subfigure}[b]{0.5\textwidth}
    \begin{dot2tex}[neato,options=-tmath]
        \input{test_abc.input.dot}
    \end{dot2tex}
    \caption{Entrada}
    \label{fig:reduce:abc:entrada}
  \end{subfigure}%
  ~
  \begin{subfigure}[b]{0.5\textwidth}
    \begin{dot2tex}[neato,options=-tmath]
        \input{test_abc.reduced.dot}
    \end{dot2tex}
    \caption{Saída}
    \label{fig:reduce:abc:saida}
  \end{subfigure}
  \caption{Redução aplicada a um grafo simples.}
  \label{fig:reduce:abc}
\end{figure}

Pode-se facilmente validar o algoritmo com um teste de mesa na
Figura~\ref{fig:reduce:abc}, ou mesmo na Figura~\ref{fig:intro}.

Olhando-se para a Figura~\ref{fig:reduce:abc}, vemos que os saldos dos
correntistas são os mesmos (\textit{i.e.}, o correntista $1$ teve uma redução de
$100$ em seu saldo, o correntista $2$ teve um aumento de $50$, bem como o
correntista $3$). A única coisa que mudou entre a
Figura~\ref{fig:reduce:abc:entrada} e a Figura~\ref{fig:reduce:abc:saida} foram
os valores e os destinos das transferências. Somando-se e multiplicando pelo
valor do imposto, vemos que na Figura~\ref{fig:reduce:abc:entrada} pagaríamos
$1.50$ de imposto (\textit{i.e.}, $1\%$ de $150$), enquanto na
Figura~\ref{fig:reduce:abc:saida} pagaríamos $1.00$ de impost (\textit{i.e.},
$1\%$ de $100$).

\section{Resultados}\label{sec:resultados}

\begin{table}[H]
  \centering
\begin{tabular}{||c|c||c|c|c||}
  \hline
Teste & Economia & Transações & Tempo de Execução \\ [0.5ex]
  \hline\hline
  1 & 3980.31 & 264 & 0.17s \\
  \hline
  2 & 3329.03 & 235 & 0.17s \\
  \hline
  3 & 1905.99 & 165 & 0.08s \\
  \hline
  4 & 1545.48 & 140 & 0.06s \\
  \hline
  5 & 925.53  & 99 & 0.06s \\
  \hline
  6 & 2288.34 & 186 & 0.10s \\
  \hline
  7 & 609.39  & 91 & 0.05s \\
  \hline
  8 & 3029.33 & 232 & 0.14s \\
  \hline
  9 & 1991.52 & 165 & 0.09s \\
  \hline
  10 & 1912.52 & 153 & 0.07s \\
\hline
\end{tabular}

\label{tab:resultados}
\caption{Resultados dos testes da Turma 128}
\end{table}

\end{document}
